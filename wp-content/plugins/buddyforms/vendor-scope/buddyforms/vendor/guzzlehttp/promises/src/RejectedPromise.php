<?php
 namespace tk\GuzzleHttp\Promise; class RejectedPromise implements \tk\GuzzleHttp\Promise\PromiseInterface { private $reason; public function __construct($reason) { if (\is_object($reason) && \method_exists($reason, 'then')) { throw new \InvalidArgumentException('You cannot create a RejectedPromise with a promise.'); } $this->reason = $reason; } public function then(callable $onFulfilled = null, callable $onRejected = null) { if (!$onRejected) { return $this; } $queue = \tk\GuzzleHttp\Promise\Utils::queue(); $reason = $this->reason; $p = new \tk\GuzzleHttp\Promise\Promise([$queue, 'run']); $queue->add(static function () use($p, $reason, $onRejected) { if (\tk\GuzzleHttp\Promise\Is::pending($p)) { try { $p->resolve($onRejected($reason)); } catch (\Throwable $e) { $p->reject($e); } catch (\Exception $e) { $p->reject($e); } } }); return $p; } public function otherwise(callable $onRejected) { return $this->then(null, $onRejected); } public function wait($unwrap = \true, $defaultDelivery = null) { if ($unwrap) { throw \tk\GuzzleHttp\Promise\Create::exceptionFor($this->reason); } return null; } public function getState() { return self::REJECTED; } public function resolve($value) { throw new \LogicException("Cannot resolve a rejected promise"); } public function reject($reason) { if ($reason !== $this->reason) { throw new \LogicException("Cannot reject a rejected promise"); } } public function cancel() { } } 